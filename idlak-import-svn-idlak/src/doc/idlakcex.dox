// doc/idlakcex.dox

// Copyright 2013 University of Edinburgh

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//  http://www.apache.org/licenses/LICENSE-2.0

// THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
// WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
// MERCHANTABLITY OR NON-INFRINGEMENT.
// See the Apache 2 License for the specific language governing permissions and
// limitations under the License.

/**
 \page idlakcex The Idlak context extraction system

 @section idlakcex_intro Introduction

In order to train our speech synthesiser, we need to extract information about the 
context in which each phone exists. For example, desirable information might be the 
phones in proximity to it, its position within the segment or syllabic stress. The 
role of idlakcex is to take the idlaktxp output and perform this extraction.

It outputs a string for each phone, which consists of values separated
by unique delimiters, indicating which context the subsequent
value pertains to. These full context models are very similar to
model names used in HTS/HTK but with some regularisation.

For example here is a full contect model name in HTS/HTK

\verbatim
ae^l-ax+s=w@2_2/A:1_1_1/B:0-0-3@2-1&2-21
#1-12$1-3!1-1;1-7|ax/C:1+0+3/D:0_0
/E:content+2@1+15&1+7#0+2/F:aux_1
/G:0_0/H:22=15^1=1|NONE/I:0=0/J:22+15-1
\endverbatim

The delimiters shift on each field to allow a regular expression to
uniquely extract a field. This follows the initial HTK style of naming
triphones and quinphones for ASR. In the above we have phone contexts
in the first 5 fields:

<table>
<tr><th>context</th><th>left delimiter</th><th>value</th><th>right delimiter</th></tr>
<tr><th>left left phone context</th><th></th><th>ae</th><th>^</th></tr>
<tr><th>left phone context</th><th>^</th><th>l</th><th>-</th></tr>
<tr><th>phone context</th><th>-</th><th>ax</th><th>+</th></tr>
<tr><th>right phone context</th><th>+</th><th>s</th><th>=</th></tr>
<tr><th>right right phone context</th><th>=</th><th>w</th><th>\@</th></tr>
</table>

Idlak continues to use the HTK style phone delimiters, but as standard replaces
all other delimiters with the string /XX: where XX is a two digit
field number. This makes the models a little longer but easier to
intepret.

For example:

\verbatim
^pau~ae-l+ah=s/00:0/01:2/02:1/03:0/04:1/05:PAU
/06:NN/07:VBD/08:1/09:3/10:3/11:0/12:2/13:1
/14:15/17:LL
\endverbatim

Field values can be integers or strings as in HTS/HTK.

These string names are an intermediate form in Kaldi. In the standard
Kaldi system phone names are replaced by integer values. This is not
possible with the full context models used in synthesis because the
large number of contexts leads to trillions of different possible
phone names. Thus internally in Kladi Idlak phone names are coded as a
vector of integers. Each position on the vector refers to a context
and each integer to a vlaue, either a direct integer value, or an
index into a lookup table to represent a string value.

A key requirement for current parametric synthesis systems is to be
able to query a phone name for a context value, and build a tree of
models in order to automatically group the very sparse set of full
context models to a less sparse set of leaf models.

The question set is a list where each question has the form given this
context are any of these values present.

In HTK such questions are written as follows:
\verbatim
QS "LL-Stop" {^b~*,^d~*,^g~*,^k~*,^p~*,^t~*}
\endverbatim
whereas in Kladi Idlak they would have the form
\verbatim
5 ? 7 9 15 20 27 31
\endverbatim

The context index is the first value and matches our context fields in
our phone name with an offset of 5. This is for compatibility reasons
with Kaldi where, given a context width of 5 and a central position of
3 (i.e. --central-position=2 --context-width=5 in tree building
options), the first five contexts are repeated quinphone contexts
where questions may be generated automatically.

Unlike HTS where the questions are set in advance and not altered, in
Kaldi Idlak they are generated from a superset, making it easier to
alter, add, and remove contexts and context values while ensuring the
questions remain synchonised with the with the context extraction.

In the next two sections we give more detail on how context extraction is
configured, and how the question sets are generated.

@section idlakcex_archi Context Architecture

The system's primary mode of action is to run each of the context extraction functions. 
The developer writes the function bodies, adhering to a function naming convention to be 
explained later, whilst the header file and a macro for calling them all are automatically 
generated by a Python script.

The functions themselves must also be described in an XML file, including the following 
information:

 - \b delim: The delimiter to be used in the output string, ahead of this feature's value.

 - \b htsname: The name by which the feature is referred to in HTS.

 - \b desc: A short description of the feature's purpose.

 - \b name: The name of the feature. This is used as part of the function name in the C++ 
file, so should conform to those standards.

 - \b min (optional): The minimum acceptable value for this feature.

 - \b max (optional): The maximum acceptable value for this feature.

 - \b set (optional): If this feature is to have non-integer values, the set from which 
possible values should be drawn.

 - \b pauctx (optional): Whether or not context should continue (as opposed to being blocked) 
when meeting two consecutive pauses.

If the 'set' attribute is used, a set element must be defined, using the same name, which 
enumerates all possible values for the set.

Below is an example of such an XML file:

 \verbatim
<cex maxfieldlen="3" pausehandling="SPT">
  <!-- Sets must be specified before feature functions that depend on them -->
  <set name="phone" null="X">
    <item name="pau"/>
    <item name="aa"/>
    <item name="ae"/>
    <item name="ah"/>
    <item name="ao"/>
    <item name="aw"/>
    <item name="ax"/>
    <item name="ay"/>
    <item name="b"/>
    <item name="ch"/>
    <item name="d"/>
    <item name="dx"/>
    <item name="dh"/>
    <item name="eh"/>
    <item name="er"/>
    <item name="ey"/>
    <item name="f"/>
    <item name="g"/>
    <item name="hh"/>
    <item name="ih"/>
    <item name="iy"/>
    <item name="jh"/>
    <item name="k"/>
    <item name="l"/>
    <item name="m"/>
    <item name="n"/>
    <item name="ng"/>
    <item name="ow"/>
    <item name="oy"/>
    <item name="p"/>
    <item name="r"/>
    <item name="s"/>
    <item name="sh"/>
    <item name="t"/>
    <item name="th"/>
    <item name="uh"/>
    <item name="uw"/>
    <item name="v"/>
    <item name="w"/>
    <item name="y"/>
    <item name="z"/>
    <item name="zh"/>
    <item name="sil"/>
    <item name="X"/>
  </set>
  <set name="pos" null="X">
    <item name="CC"/>
    <item name="CD"/>
    <item name="DT"/>
    <item name="EX"/>
    <item name="FW"/>
    <item name="IN"/>
    <item name="IN/that"/>
    <item name="JJ"/>
    <item name="JJR"/>
    <item name="JJS"/>
    <item name="LS"/>
    <item name="MD"/>
    <item name="NN"/>
    <item name="NNS"/>
    <item name="NP"/>
    <item name="NPS"/>
    <item name="PDT"/>
    <item name="POS"/>
    <item name="PP"/>
    <item name="PP$"/>
    <item name="RB"/>
    <item name="RBR"/>
    <item name="RBS"/>
    <item name="RP"/>
    <item name="SENT"/>
    <item name="SYM"/>
    <item name="TO"/>
    <item name="UH"/>
    <item name="VB"/>
    <item name="VBD"/>
    <item name="VBG"/>
    <item name="VBN"/>
    <item name="VBP"/>
    <item name="VBZ"/>
    <item name="VD"/>
    <item name="VDD"/>
    <item name="VDG"/>
    <item name="VDN"/>
    <item name="VDP"/>
    <item name="VDZ"/>
    <item name="VHB"/>
    <item name="VHD"/>
    <item name="VHI"/>
    <item name="VHP"/>
    <item name="VHZ"/>
    <item name="VV"/>
    <item name="VVD"/>
    <item name="VVG"/>
    <item name="VVN"/>
    <item name="VVP"/>
    <item name="VVZ"/>
    <item name="WDT"/>
    <item name="WP"/>
    <item name="WP$"/>
    <item name="WRB"/>
    <item name=":"/>
    <item name="$"/>
    <item name="PAU"/>
    <item name="X"/>
  </set>
  <set name="tone" null="X">
    <item name="LH"/>
    <item name="LL"/>
    <item name="X"/>
  </set>
  <feat delim="^" htsname="LL" desc="phone_before_before" name="BackwardBackwardPhone" set="phone" pauctx="false">
    <mapping fromstr="X" tostr="sil"/>
  </feat>
  <feat delim="~" htsname="L" desc="phone_before" name="BackwardPhone" set="phone" pauctx="false">
    <mapping fromstr="X" tostr="sil"/>
  </feat>
  <feat delim="-" htsname="C" desc="current_phone" name="Phone" set="phone" pauctx="false">
    <mapping fromstr="X" tostr="sil"/>
  </feat>
  <feat delim="+" htsname="R" desc="phone_forward" name="ForwardPhone" set="phone" pauctx="false">
    <mapping fromstr="X" tostr="sil"/>
  </feat>
  <feat delim="=" htsname="RR" desc="phone_forward_forward" name="ForwardForwardPhone" set="phone" pauctx="false">
    <mapping fromstr="X" tostr="sil"/>
  </feat>
  <feat delim="/00:" htsname="Seg_Fw" desc="segment_location_from_front" name="SegmentLocationFromFront" min="0" max="7" >
  <feat delim="/01:" htsname="Seg_Bw" desc="segment_location_from_back" name="SegmentLocationFromBack" min="0" max="7" />
  <feat delim="/02:" htsname="L-Syl_Stress" desc="left_syllabic_stress" name="BackwardSyllableStress" min="0" max="1" pauctx="false" />
  <feat delim="/03:" htsname="C-Syl_Stress" desc="current_syllabic_stress" name="SyllableStress" min="0" max="1" pauctx="false" />
  <feat delim="/04:" htsname="R-Syl_Stress" desc="right_syllabic_stress" name="ForwardSyllableStress" min="0" max="1" pauctx="false" />
  <feat delim="/05:" htsname="L-Word_GPOS" desc="left_part_of_speech" name="BackwardWordPosTag" set="pos" pauctx="false" />
  <feat delim="/06:" htsname="C-Word_GPOS" desc="part_of_speech" name="WordPosTag" set="pos" pauctx="false" />
  <feat delim="/07:" htsname="R-Word_GPOS" desc="right_part_of_speech" name="ForwardWordPosTag" set="pos" pauctx="false" />
  <feat delim="/08:" htsname="L-Syl_Num-Segs" desc="left_syllable_no_segments" name="BackwardSyllableNumPhones" min="0" max="7"/>
  <feat delim="/09:" htsname="C-Syl_Num-Segs" desc="current_syllable_no_segments" name="SyllableNumPhones" min="0" max="7"/>
  <feat delim="/10:" htsname="R-Syl_Num-Segs" desc="right_syllable_no_segments" name="ForwardSyllableNumPhones" min="0" max="7"/>
  <feat delim="/11:" htsname="L-Word_Num-Syls" desc="-" name="BackwardWordNumSyls" min="0" max="7"/>
  <feat delim="/12:" htsname="C-Word_Num-Syls" desc="-" name="WordNumSyls" min="0" max="7"/>
  <feat delim="/13:" htsname="R-Word_Num-Syls" desc="-" name="ForwardWordNumSyls" min="0" max="7"/>
  <feat delim="/14:" htsname="C-Phrase_Num-Words" desc="-" name="PhraseNumWords" min="0" max="30"/>
  <feat delim="/17:" htsname="C-Phrase_TOBI_End-tone" desc="-" name="PhraseTobiEndTone" set="tone"/>
</cex>
\endverbatim

Function names in the C++ should contain the following components in the following order:

 - \b CexFunc
 - \b String or \b Int: depending on the feature's value type.
 - The contents of the 'name' field in the XML file.

For example, given the previously-mentioned XML file, the following
would be legitimate function names; \e
CexFuncStringBackwardBackwardPhone, \e CexFuncIntWordNumSyls, \e
CexFuncStringPhraseTobiEndTone.

@section idlaxcex_extraction Context Extraction

idlakcex takes output from the front end processor idlaktxp as input,
queries the XMl structures within the input and adds the full context
model names. It also adds a header to the XMl which describes the
context extraction functions used. This helps track errors and is also
used to encode full context models into kaldi style integer vectors.

An example of running the idlakcex on input generated by the idlak
test system is shown below.

\verbatim
cd src/idlaktxp
make test
cd ../idlaktxpbin
./idlakcex --pretty --cex-arch=hts --tpdb=../../idlak-data/en/ga ../idlaktxp/test_data/mod-syllabify-out002.xml -
\endverbatim

The switch --pretty adds whitespace to the XMl to make it human
readable, --cex-arch argument can be used to switch between different
setups. In this example it is set to hts which produces context models
names with the delimeters described above, which matches the hts style
question file (see \ref idlakcex_qarchi). This output was used together with this
question file to test the front end against festival using HTS (see \ref idlakhtstest).

the first few lines of the output are as follows:
\verbatim
<?xml version="1.0"?>
<parent>
	<txpheader>
		<cex>
			<cexfunction name="BackwardBackwardPhone" delim="^" isinteger="0" />
			<cexfunction name="BackwardPhone" delim="~" isinteger="0" />
			<cexfunction name="Phone" delim="-" isinteger="0" />
			<cexfunction name="ForwardPhone" delim="+" isinteger="0" />
			<cexfunction name="ForwardForwardPhone" delim="=" isinteger="0" />
			<cexfunction name="SegmentLocationFromFront" delim="/00:" isinteger="1" />
			<cexfunction name="SegmentLocationFromBack" delim="/01:" isinteger="1" />
			<cexfunction name="BackwardSyllableStress" delim="/02:" isinteger="1" />
			<cexfunction name="SyllableStress" delim="/03:" isinteger="1" />
			<cexfunction name="ForwardSyllableStress" delim="/04:" isinteger="1" />
			<cexfunction name="BackwardWordPosTag" delim="/05:" isinteger="0" />
			<cexfunction name="WordPosTag" delim="/06:" isinteger="0" />
			<cexfunction name="ForwardWordPosTag" delim="/07:" isinteger="0" />
			<cexfunction name="BackwardSyllableNumPhones" delim="/08:" isinteger="1" />
			<cexfunction name="SyllableNumPhones" delim="/09:" isinteger="1" />
			<cexfunction name="ForwardSyllableNumPhones" delim="/10:" isinteger="1" />
			<cexfunction name="BackwardWordNumSyls" delim="/11:" isinteger="1" />
			<cexfunction name="WordNumSyls" delim="/12:" isinteger="1" />
			<cexfunction name="ForwardWordNumSyls" delim="/13:" isinteger="1" />
			<cexfunction name="PhraseNumWords" delim="/14:" isinteger="1" />
			<cexfunction name="PhraseTobiEndTone" delim="/17:" isinteger="0" />
		</cex>
	</txpheader>
	<utt uttid="1" no_phrases="2">
		<spt phraseid="1" no_wrds="2">
			<ws col="0" />
			<break type="4" time="0.011">
				<tk pron="pau">
					<syl val="pau">
						<phon val="pau">^sil~sil-pau+hh=ah/00:0/01:0/02:0/03:0/04:0/05:PAU/06:PAU/07:NN/08:0/09:0/10:2/11:0/12:0/13:2/14:2/17:LL</phon>
					</syl>
				</tk>
			</break>
			<tk norm="hello" lc="true" uc="true" pos="NN" posset="1" wordid="1" pron="hh ah0 l ow1" altprons="hh eh0 l ow1, hh ah0 l ow1" spron="hh+ah0|l+ow1|" nosyl="2">
				Hello
				<ws />
				<syl val="hh+ah0" stress="0" sylid="1" nophons="2">
					<phon val="hh" type="onset" phonid="1">^sil~pau-hh+ah=l/00:0/01:1/02:0/03:0/04:1/05:PAU/06:NN/07:EX/08:0/09:2/10:2/11:0/12:2/13:1/14:2/17:LL</phon>
					<phon val="ah" type="nucleus" phonid="2">^pau~hh-ah+l=ow/00:1/01:0/02:0/03:0/04:1/05:PAU/06:NN/07:EX/08:0/09:2/10:2/11:0/12:2/13:1/14:2/17:LL</phon>
				</syl>
				<syl val="l+ow1" stress="1" sylid="2" nophons="2">
					<phon val="l" type="onset" phonid="1">^hh~ah-l+ow=dh/00:0/01:1/02:0/03:1/04:1/05:PAU/06:NN/07:EX/08:2/09:2/10:3/11:0/12:2/13:1/14:2/17:LL</phon>
					<phon val="ow" type="nucleus" phonid="2">^ah~l-ow+dh=eh/00:1/01:0/02:0/03:1/04:1/05:PAU/06:NN/07:EX/08:2/09:2/10:3/11:0/12:2/13:1/14:2/17:LL</phon>
				</syl>
			</tk>
...
\endverbatim

If we run the program with the switch altered to --cex-arch=kaldi the
model names are altered replacing delimeters between all non phone
contexts with whitespace.

\verbatim
...
<phon val="pau">^0~0-0+hh=ah 0 0 0 0 0 PAU PAU NN 0 0 2 0 0 2 2 LL</phon>
...
<phon val="hh" type="onset" phonid="1">^0~0-hh+ah=l 0 1 0 0 1 PAU NN EX 0 2 2 0 2 1 2 LL</phon>
... etc.
\endverbatim

The --cex-arch switch causes the program to load different setup files
from the tpdb (text processing database) in these examples either
../../idlak-data/en/ga/cex-hts.xml or
../../idlak-data/en/ga/cex-kaldi.xml

See voicebuilding documentation for more detail (\ref idlakvoicebuild).

@section idlakcex_qarchi Question Architecture

The front end procesing and the context extraction associated with it
can be used standalone within Kaldi Idlak in order to generate
linguistic analysis or for other backend TTS systems.

The question architecture is part of the Idlak voice build system but
is closely linked to the context extraction system. This is because,
within parametric TTS systems questions are used to help take the very
sparse full context models and group them into combined models. It is
vital that the context extraction matches such question files. If they
do not the voice training behavior becomes unspecified, often without
being able to detect errors and mismatches, and producing very hard to
detect output errors.

The Idlak Question Architecture is designed to:

-# Minimise the chance of mismatches between questions and contexts.

-# Produce warnings for unusual context extraction results (e.g. no variation, unusual values)

-# To make it easy to choose contexts and questions from a superset
   allowing experimentation and development of optimal sets.

A question set based on the HTS question set distributed with the HTS
DEMO is included in the system. Selecting a subset of these questions
and contexts is a simple process, adding new questions and new context
extraction is more complex requiring a careful march between cex
configuration code, the question set, and C++ context extraction
functions (see \ref idlakcex_addcex and \ref idlakcex_addqst).

The default question set used in voice building is
../../idlak-data/en/ga/qset-default.xml in order to allow cross
development between HTKHTS and Kaldi Idlak names familiar to HTS users
are used as well as Idlak context function names. 

In HTK such questions are written as follows:
\verbatim
QS "LL-Stop" {^b~*,^d~*,^g~*,^k~*,^p~*,^t~*}
\endverbatim
whereas in Kladi Idlak they would have the form
\verbatim
5 ? 7 9 15 20 27 31
\endverbatim

In HTS, the delimeters identify the context, in Kaldi the index of the
context is used. HTS question style names are used within Kaldi to
help make warnings and error output easier to understand.

Below is an example of the XML specification of a question:
\verbatim        
<?xml version="1.0" ?>
<qset>
 ...		
        <feat htsname="C-Syl_Stress" name="SyllableStress">
                <qs name="C-Syl_Stress==0">
                        0
                </qs>
                <qs name="C-Syl_Stress==1">
                        1
                </qs>
        </feat>
...
</qset>
\endverbatim

The questions qs are stored by the context they are tied with. The
context is identified by an HTS name for convnenience and by the
context extraction function name (as per the cex configuration file)
WHICH MUST EXACTLY MATCH THE CONTEXT EXTRACTION FUNCTION WRITTEN IN
C++. During voice building only questions matching the contexts which
are selected for that voice build are used. The valid values for a yes
reponse are space delimited and must match the context type (string or
integer).

The process for encoding questions in Kaldi format in the voice
building system is as follows:

-# Create a lookup table for all string contexts which map an integer
   onto the string value. 0 is reserved for a NULL value (defined in
   the cex configuration which is typically '0'.

-# The frequency of all features values and appropriate lookup tables
   are stored by the context index based on the header output from
   cex. For exampl cex000_freq.txt and cex000_lkp.txt relate to the
   function BackwardBackwardPhone.

-# The index of the context is incremented by 5 to deal with the
   automatically generated questions based on a quinphone model.

-# In kaldi built trees the context -1 is the state number of the
   model within the phone. This differes from HTK where a seperate
   tree is built for each state

@section idlakcex_addcex Adding Context Extraction Functions

IN PREPARATION

@section idlakcex_addqst Adding Context Questions

IN PREPARATION

*/
